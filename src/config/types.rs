//! Configuration types and CLI options.
//!
//! This module defines enums and structs used for command-line argument parsing
//! and configuration.

use std::path::PathBuf;

use clap::{Parser, ValueEnum};

use crate::config::constants::DEFAULT_USER_AGENT;

/// Logging level for the application.
///
/// Controls the verbosity of log output, from most restrictive (Error) to most
/// verbose (Trace). Used with the `--log-level` CLI option.
#[derive(Clone, Debug, ValueEnum)]
pub enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

impl From<LogLevel> for log::LevelFilter {
    fn from(l: LogLevel) -> Self {
        match l {
            LogLevel::Error => log::LevelFilter::Error,
            LogLevel::Warn => log::LevelFilter::Warn,
            LogLevel::Info => log::LevelFilter::Info,
            LogLevel::Debug => log::LevelFilter::Debug,
            LogLevel::Trace => log::LevelFilter::Trace,
        }
    }
}

/// Log output format.
///
/// Controls how log messages are formatted:
/// - `Plain`: Human-readable format with colors (default)
/// - `Json`: Structured JSON format for machine parsing
#[derive(Clone, Debug, ValueEnum)]
pub enum LogFormat {
    Plain,
    Json,
}

/// Command-line options and configuration.
///
/// This struct is automatically generated by `clap` from the field attributes.
/// All options have sensible defaults and can be overridden via command-line flags.
///
/// # Examples
///
/// ```bash
/// # Basic usage
/// domain_status urls.txt
///
/// # With custom concurrency and timeout
/// domain_status urls.txt --max-concurrency 100 --timeout-seconds 5
///
/// # With custom database path
/// domain_status urls.txt --db-path ./custom.db
/// ```
#[derive(Debug, Parser)]
#[command(
    name = "domain_status",
    about = "Checks a list of URLs for their status and redirection."
)]
pub struct Opt {
    /// File to read
    #[arg(value_parser)]
    pub file: PathBuf,

    /// Log level: error|warn|info|debug|trace
    #[arg(long, value_enum, default_value_t = LogLevel::Info)]
    pub log_level: LogLevel,

    /// Log format: plain|json
    #[arg(long, value_enum, default_value_t = LogFormat::Plain)]
    pub log_format: LogFormat,

    /// Database path (SQLite file)
    #[arg(long, value_parser, default_value = "./url_checker.db")]
    pub db_path: PathBuf,

    /// Maximum concurrent requests
    ///
    /// Increased default from 20 to 30 for better throughput while maintaining low bot detection risk.
    /// High concurrency can trigger rate limiting even with low RPS.
    #[arg(long, default_value_t = 30)]
    pub max_concurrency: usize,

    /// Per-request timeout in seconds
    #[arg(long, default_value_t = 10)]
    pub timeout_seconds: u64,

    /// HTTP User-Agent header value.
    ///
    /// Defaults to a Chrome-like browser string. Can be overridden to match
    /// specific browser versions or patterns. For better bot evasion, consider
    /// using a recent browser version or rotating User-Agent strings.
    #[arg(long, default_value = DEFAULT_USER_AGENT)]
    pub user_agent: String,

    /// Initial requests per second (adaptive rate limiting always enabled)
    ///
    /// Rate limiting automatically adjusts based on error rates:
    /// - Starts at this RPS value
    /// - Reduces by 50% when error rate exceeds threshold (default: 20%)
    /// - Increases by 15% when error rate is below threshold
    /// - Minimum RPS: 1, Maximum RPS: 2x this initial value (allows system to adapt to good conditions)
    ///
    /// Set to 0 to disable rate limiting (not recommended for production).
    #[arg(long, default_value_t = 15)]
    pub rate_limit_rps: u32,

    /// Error rate threshold for adaptive rate limiting (0.0-1.0, default: 0.2 = 20%)
    ///
    /// When error rate (429s + timeouts) exceeds this threshold, RPS is reduced.
    /// Advanced option - default 20% works well for most cases.
    #[arg(long, default_value_t = 0.2, hide = true)]
    pub adaptive_error_threshold: f64,

    /// Fingerprints source URL or local path (default: HTTP Archive)
    /// Examples:
    ///   --fingerprints https://raw.githubusercontent.com/HTTPArchive/wappalyzer/main/src/technologies
    ///   --fingerprints /path/to/technologies.json
    #[arg(long)]
    pub fingerprints: Option<String>,

    /// GeoIP database path (MaxMind GeoLite2 .mmdb file) or download URL
    /// Examples:
    ///   --geoip /path/to/GeoLite2-City.mmdb
    ///   --geoip https://download.maxmind.com/app/geoip_download?edition_id=GeoLite2-City&license_key=YOUR_KEY&suffix=tar.gz
    /// If not provided, GeoIP will auto-download if MAXMIND_LICENSE_KEY env var is set.
    /// Otherwise, GeoIP lookup is disabled.
    #[arg(long)]
    pub geoip: Option<String>,

    /// HTTP status server port (optional, disabled by default)
    ///
    /// When set, starts a lightweight HTTP server that exposes:
    /// - `/metrics` - Prometheus-compatible metrics
    /// - `/status` - JSON status endpoint with progress information
    ///
    /// Useful for monitoring long-running jobs. The server runs in the background
    /// and does not block URL processing. Example: `--status-port 8080`
    #[arg(long)]
    pub status_port: Option<u16>,

    /// Enable WHOIS/RDAP lookup for domain registration information
    ///
    /// When enabled, performs WHOIS/RDAP queries to fetch:
    /// - Domain creation date
    /// - Domain expiration date
    /// - Registrar information
    /// - Registrant details
    ///
    /// **Rate Limiting**: WHOIS queries are rate-limited to 1 query per 2 seconds
    /// (0.5 queries/second) by default to respect registrar limits. This is separate
    /// from HTTP rate limiting and will slow down processing when enabled.
    ///
    /// **Caching**: WHOIS data is cached for 7 days to avoid redundant queries.
    ///
    /// **Default**: Disabled (off) to maintain fast processing speeds.
    /// Enable only when domain age/registrar information is needed.
    #[arg(long)]
    pub enable_whois: bool,

    /// Show detailed timing metrics at the end of the run
    ///
    /// When enabled, displays a breakdown of time spent in each operation:
    /// - HTTP requests
    /// - DNS lookups
    /// - TLS handshakes
    /// - Technology detection
    /// - HTML parsing
    /// - Enrichment operations
    ///
    /// Useful for performance analysis and identifying bottlenecks.
    /// Disabled by default to reduce output noise.
    #[arg(long)]
    pub show_timing: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_log_level_conversion() {
        // Test all LogLevel variants convert correctly to log::LevelFilter
        assert_eq!(
            log::LevelFilter::from(LogLevel::Error),
            log::LevelFilter::Error
        );
        assert_eq!(
            log::LevelFilter::from(LogLevel::Warn),
            log::LevelFilter::Warn
        );
        assert_eq!(
            log::LevelFilter::from(LogLevel::Info),
            log::LevelFilter::Info
        );
        assert_eq!(
            log::LevelFilter::from(LogLevel::Debug),
            log::LevelFilter::Debug
        );
        assert_eq!(
            log::LevelFilter::from(LogLevel::Trace),
            log::LevelFilter::Trace
        );
    }

    #[test]
    fn test_log_level_ordering() {
        // Verify that log levels are ordered correctly (Error < Warn < Info < Debug < Trace)
        let error = log::LevelFilter::from(LogLevel::Error);
        let warn = log::LevelFilter::from(LogLevel::Warn);
        let info = log::LevelFilter::from(LogLevel::Info);
        let debug = log::LevelFilter::from(LogLevel::Debug);
        let trace = log::LevelFilter::from(LogLevel::Trace);

        // Each level should be more restrictive than the next
        assert!(error < warn);
        assert!(warn < info);
        assert!(info < debug);
        assert!(debug < trace);
    }

    #[test]
    fn test_log_format_variants() {
        // Test that LogFormat enum variants can be created and compared
        let plain = LogFormat::Plain;
        let json = LogFormat::Json;

        // Both should be valid variants
        match plain {
            LogFormat::Plain => {}
            LogFormat::Json => panic!("Plain should not match Json"),
        }

        match json {
            LogFormat::Plain => panic!("Json should not match Plain"),
            LogFormat::Json => {}
        }
    }

    #[test]
    fn test_log_format_debug() {
        // Test Debug trait implementation
        let plain = LogFormat::Plain;
        let json = LogFormat::Json;

        // Should not panic when formatting
        let plain_str = format!("{:?}", plain);
        let json_str = format!("{:?}", json);

        assert_eq!(plain_str, "Plain");
        assert_eq!(json_str, "Json");
    }

    #[test]
    fn test_log_level_debug() {
        // Test Debug trait implementation for LogLevel
        let error = LogLevel::Error;
        let warn = LogLevel::Warn;
        let info = LogLevel::Info;
        let debug = LogLevel::Debug;
        let trace = LogLevel::Trace;

        // Should not panic when formatting
        assert_eq!(format!("{:?}", error), "Error");
        assert_eq!(format!("{:?}", warn), "Warn");
        assert_eq!(format!("{:?}", info), "Info");
        assert_eq!(format!("{:?}", debug), "Debug");
        assert_eq!(format!("{:?}", trace), "Trace");
    }

    #[test]
    fn test_log_level_clone() {
        // Test Clone trait implementation
        let original = LogLevel::Info;
        let cloned = original.clone();

        // Both should convert to the same LevelFilter
        assert_eq!(
            log::LevelFilter::from(original),
            log::LevelFilter::from(cloned)
        );
    }

    #[test]
    fn test_log_format_clone() {
        // Test Clone trait implementation
        let original = LogFormat::Plain;
        let cloned = original.clone();

        // Both should be the same variant
        match (original, cloned) {
            (LogFormat::Plain, LogFormat::Plain) => {}
            (LogFormat::Json, LogFormat::Json) => {}
            _ => panic!("Cloned value should match original"),
        }
    }
}
